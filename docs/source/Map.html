<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='global-property-'>/**
</span> * Copyright (c) 2012 The Open Source Geospatial Foundation
 * 
 * Published under the BSD license. 
 * 
 * See https://raw.github.com/geoext/GXM/master/license.txt for the full 
 * text of the license.
 */

<span id='global-property-'>/**
</span> * @requires GXM/data/LayerStore.js
 * @requires GXM/util/Base.js
 */

<span id='global-property-'>/** api: (define)
</span> *  module = GXM
 *  class = Map
 *  base_link = `Ext.Component &lt;http://docs.sencha.com/touch/2-0/#!/api/Ext.Component&gt;`_
 */

<span id='global-property-'>/** api: example
</span> *  Sample code to create a GXM.Map that fills the whole screen:
 * 
 *  .. code-block:: javascript
 *  
 *    Ext.setup({
 *        onReady: function(){
 *            var mp = Ext.create('GXM.Map', {
 *                layers: [            
 *                    // an array of OpenLayers.Layer-objects
 *                ],
 *                // set the center of the map
 *                mapCenter: [8, 51],
 *                // control the initial zoomlevel
 *                mapZoom: 11
 *            });
 *        } // end of the onReady-funcion
 *    });
 *    
 */

<span id='GXM-Map'>/** api: constructor
</span> *  .. class:: Map(config)
 *   
 *      The class that is used to build a GXM map.
 */
Ext.define('GXM.Map', {
    
    requires: [
        'GXM.util.Base',
        'GXM.data.LayerStore'
    ],
    
    extend: 'Ext.Component',
    xtype : 'gxm_map',
    
    // both 'layers' and 'controls' are not defined via 'config'-object,
    // so that we do not ave to decide what happens on call of e.g.
    // setLayers() / setControls()
    
<span id='GXM-Map-property-'>    /** api: config[layers]
</span>     * 
     *  ``Array(OpenLayers.Layer)``
     *  The layers provided here will be added to this MapPanel's map.
     */
    
<span id='GXM-Map-property-layers'>    /** api: property[layers]
</span>     * 
     *  :class:`GXM.data.LayerStore`  A store containing gxm_layer-model 
     *  instances.
     */
    layers: null,
    
<span id='GXM-Map-property-controls'>    /** api: config[controls]
</span>     * 
     *  ``Array(OpenLayers.Control)``
     *  The layers provided here will be added to this MapPanel's map.
     */
    controls: null,
    
    config: {
    	
<span id='GXM-Map-property-map'>        /** api: config[map]
</span>         * 
         *  ``OpenLayers.Map or Object``  A configured map or a configuration object
         *  for the map constructor.  A configured map will be available after
         *  construction through the :func:`getMap()` function.
         */
        map: null,
        
<span id='GXM-Map-property-mapCenter'>        /** api: config[mapCenter]
</span>         * 
         *  ``OpenLayers.LonLat, Array(Number) or String``  A location for the 
         *  initial map center.  If an array is provided, the first two items should
         *  represent x &amp; y coordinates. If a string is provided, it should consist
         *  of a x &amp; y coordinate seperated by a comma.
         */
        mapCenter: null,
        
<span id='GXM-Map-property-mapZoom'>        /** api: config[mapZoom]
</span>         * 
         *  ``Number``  An initial zoom level for the map.
         */
        mapZoom: null,
        
<span id='GXM-Map-property-mapExtent'>        /** api: config[mapExtent]
</span>         * 
         *  ``OpenLayers.Bounds or Array(Number)``  An initial extent for the map 
         *  (used if center and zoom are not provided.  If an array, the first four 
         *  items should be minx, miny, maxx, maxy.
         */
        mapExtent: null
    },
    
<span id='GXM-Map-method-constructor'>    /** private: method[constructor]
</span>     * 
     *  The constructor function
     */
    constructor: function(config) {
        
        if (config.map instanceof OpenLayers.Map) {
            this._map = config.map;
            delete config.map;
        }
        
        this.callParent(arguments);
        this.element.setVisibilityMode(Ext.Element.OFFSETS);
    
        if (!window.OpenLayers) {
            this.setHtml('OpenLayers is required');
        }
    },
    
<span id='GXM-Map-method-initialize'>    /** private: method[initialize]
</span>     * 
     *  Initializes the Component.
     */
    initialize: function() {
        
        this.callParent();
        
        // check config-property map for an existing OpenLayers.Map-instance, 
        // a conf object for an OpenLayers.Map or null
        if ( !(this.getMap() instanceof OpenLayers.Map) ) {
            var mapConf = Ext.applyIf(this.getMap() || {}, {
                allOverlays: true,
                controls: this.initialConfig.controls || this.getDefaultControls(),
                numZoomLevels: 24
            });
            this.setMap(new OpenLayers.Map(mapConf));
        } else {
            // add any additionally configured controls:
            if (this.initialConfig.controls) {
                this.getMap().addControls(this.initialConfig.controls);
            }
        }
        
        // check property layers
        if ( this.config.layers ) {
            var layers = this.config.layers;
            
            if(this.config.layers instanceof GXM.data.LayerStore) {
                var arr = [];
                this.config.layers.each(function(rec){
                    arr.push(rec.getLayer());
                });
                layers = arr;
            }
            
            this.getMap().addLayers(layers);
        }
        
        this.layers = Ext.create('GXM.data.LayerStore', {
            data: this.getMap().layers
        });
        
        // check config-property center
        if ( Ext.isString(this.getMapCenter()) ) {
            this.setMapCenter(OpenLayers.LonLat.fromString(this.getMapCenter()));
        } else if(Ext.isArray(this.getMapCenter())) {
            this.setMapCenter(OpenLayers.LonLat.fromArray(this.getMapCenter()));
        } 
        
        // check config-property extent
        if ( Ext.isString(this.getMapExtent()) ) {
            this.setMapExtent(OpenLayers.Bounds.fromString(this.getMapExtent()));
        } else if(Ext.isArray(this.getMapExtent())) {
            this.setMapExtent(OpenLayers.Bounds.fromArray(this.getMapExtent()));
        }
        
        // bind various listeners to the corresponding OpenLayers.Map-events
        this.getMap().events.on({
            &quot;moveend&quot;: this.onMoveend,
            &quot;changelayer&quot;: this.onChangelayer,
            &quot;addlayer&quot;: this.onAddlayer,
            &quot;removelayer&quot;: this.onRemovelayer,
            scope: this
        });
        
        this.on({
            painted: 'renderMap',
            scope: this
        });
        window.m= this;
        this.element.on('touchstart', 'onTouchStart', this);
    },

<span id='GXM-Map-method-onTouchStart'>    /** private: method[onTouchStart]
</span>     * 
     *  ``Function`` makes the event unpreventable 
     */
    onTouchStart: function(e) {
        e.makeUnpreventable();
    },
    
<span id='GXM-Map-method-getDefaultControls'>    /** private: method[getDefaultControls]
</span>     * 
     *  ``Function`` Returns an array of OpenLayers.Control-instances to be used
     *  when no explicit controls were given. 
     */
    getDefaultControls: function() {
        return [
            new OpenLayers.Control.TouchNavigation(),
            new OpenLayers.Control.Attribution()
        ];   
    },
    
<span id='GXM-Map-method-renderMap'>    /** private: method[renderMap]
</span>     * 
     *  The internal method that explicitly renders the map into the dom-element
     *  of this component. Calls OpenLayers.Map::render to get the map div 
     *  populated.
     */ 
    renderMap: function(){
        var me = this;
            map = me.getMap();
        
        // This is taken from the Sencha-Touch Map-component and ensures that 
        // there is no child element inside the target div we wish to render the
        // Map in.
        // TODO: evaluate whether this is enough or whether we need an iteration 
        //       on child elements
            
//        if (me.element &amp;&amp; me.element.dom &amp;&amp; me.element.dom.firstChild) {
//            Ext.fly(me.element.dom.firstChild).destroy();
//        }
        
        map.render(me.element.dom);

        // Adjust the geographic position according to the passed config-options 
        if (!map.getCenter()) {
            if (me.getMapCenter() || me.getMapZoom() ) {
                // center and/or zoom?
                map.setCenter(me.getMapCenter(), me.getMapZoom());
            } else if (me.getMapExtent() instanceof OpenLayers.Bounds) {
                // extent
                map.zoomToExtent(me.getMapExtent(), true);
            } else {   
                map.zoomToMaxExtent();
            }    
        }
    },
    
<span id='GXM-Map-method-applyMapCenter'>    /** private: method[applyMapCenter]
</span>     * 
     *  ``Function`` implicitly called whenever :func:`setMapCenter()` is called.
     */
    applyMapCenter: function(mapCenter) {
        var ll = null,
            me = this;
        if ( Ext.isString(mapCenter) ) {
            ll = OpenLayers.LonLat.fromString(mapCenter);
        } else if(Ext.isArray(mapCenter)) {
            ll = OpenLayers.LonLat.fromArray(mapCenter);
        } else {
            ll = mapCenter;
        }
        
        if (ll instanceof OpenLayers.LonLat) {
            if (me.isPainted()) {
                this.getMap().setCenter(ll);
            }
            return ll;
        }
    },
    
<span id='GXM-Map-method-applyMapExtent'>    /** private: method[applyMapExtent]
</span>     * 
     *  ``Function`` implicitly called whenever :func:`setMapExtent()` is called.
     */
    applyMapExtent: function(mapExtent) {
        var extent = null,
            me = this;
        if ( Ext.isString(mapExtent) ) {
            extent = OpenLayers.Bounds.fromString(mapExtent);
        } else if(Ext.isArray(mapExtent)) {
            extent = OpenLayers.Bounds.fromArray(mapExtent);
        } else {
            extent = mapExtent;
        }
        
        if (extent instanceof OpenLayers.Bounds) {
            if (me.isPainted()) {
                this.getMap().zoomToExtent(extent);
            }
            return extent;
        }
    },
    
<span id='GXM-Map-method-onMoveend'>   /** private: method[onMoveend]
</span>    *
    *  The &quot;moveend&quot; listener bound to the :attr:`map`.
    */
   onMoveend: function() {
       this.fireEvent(&quot;aftermapmove&quot;);
   },

<span id='GXM-Map-method-onChangelayer'>   /** private: method[onChangelayer]
</span>    *  :param e: ``Object``
    *
    *  The &quot;changelayer&quot; listener bound to the :attr:`map`.
    */
   onChangelayer: function(e) {
       var me = this;
       if(e.property) {
           if(e.property === &quot;visibility&quot;) {
               me.fireEvent(&quot;afterlayervisibilitychange&quot;);
           } else if(e.property === &quot;order&quot;) {
               me.fireEvent(&quot;afterlayerorderchange&quot;);
           } else if(e.property === &quot;name&quot;) {
               me.fireEvent(&quot;afterlayernamechange&quot;);
           } else if(e.property === &quot;opacity&quot;) {
               me.fireEvent(&quot;afterlayeropacitychange&quot;);
           }
       }
   },

<span id='GXM-Map-method-onAddlayer'>   /** private: method[onAddlayer]
</span>    * 
    *  The &quot;addlayer&quot; listener bound to the :attr:`map`.
    */
   onAddlayer: function(olEvt) {
       var layer = olEvt.layer;
       this.layers.add(layer); 
       this.fireEvent(&quot;afterlayeradd&quot;);
   },

<span id='GXM-Map-method-onRemovelayer'>   /** private: method[onRemovelayer]
</span>    * 
    *  The &quot;removelayer&quot; listener bound to the :attr:`map`.
    */
   onRemovelayer: function(olEvt) {
       var layer = olEvt.layer;
       var record = this.layers.findRecord('id', layer.id);
       this.layers.remove(record); 
       this.fireEvent(&quot;afterlayerremove&quot;);
   }
}, 

<span id='GXM-Map-method-'>/** api: constructor
</span> *  .. class:: MapPanel(config)
 *   
 *      The class ensures the backwards compatibility to GXM 0.1
 */
function() {
    // deprecate the old class &quot;GXM.MapPanel&quot; but keep it for this version for
    // backwards compatibility
    Ext.define('GXM.MapPanel', {
        // possibly better suited would be override, but this works.
        extend: 'GXM.Map',
        initialize: function (config) {
            //&lt;debug warn&gt;
            Ext.Logger.deprecate(&quot;The class 'GXM.MapPanel' is deprecated, please use 'GXM.Map' instead&quot;, this);
            //&lt;/debug&gt;
            this.callParent(arguments);
        }
    });
    
    GXM.util.Base.createConfigAlias(GXM.Map, 'center', 'mapCenter');
    GXM.util.Base.createConfigAlias(GXM.Map, 'zoom', 'mapZoom');
    GXM.util.Base.createConfigAlias(GXM.Map, 'extent', 'mapExtent');
});
</pre>
</body>
</html>
